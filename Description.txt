1.Составить общее текстовое описание БД и решаемых ею задач;

Курсовой проект "Арбитр". 
Портал который позволяет физическим и юридическим лицам заключать безопасные сделки примерно до 1 миллиона рубле. Так как механизмы безопасной
сделки на различных порталах по продаже товаров, услуг и т.д. не предусматривают торгов и снижение цены, а также существует масса магазинов в Instagram
Facebook, VK и т.д. в которых люди покупают товры на свой риск и страх даже без гарантии отправки им товара и последующей гарантии, кроме того 
малый  да и средний бизнес сталкивается с тем, что кто-то либо оплачивает товар услугу и т.д. и ждёт его(её) получения, либо наоборот исполитель 
(поставщик) ждёт оплаты. Что бы обезопасить небольшие сделки между физическими и юридическими лицами возникла идея создать данный портал. По сути
он должне быть максимально простым и иметь мобильные верси на популярных платформах. Идея и логика такая,что пользователи оговорившись создают
на портале контракт обговарив предварительно небольшие условия(обязуюсь отправить до, подтверждаю отсутствие дефектов, подтверждаю размер, прилагаю фото и т.д.)
далее согласившись с обеих сторон с условиями внести денежные средства и ждать выполнения. После выполнения есть срок защиты примерно 10 дней
в случае если обнаружаться дефекты в процессе первой эксплуатации. 

Логика работы:
	- пользователи регистрируются на портале по номеру телефона и заполняют свой профиль(для физических и юридических лиц регистрация 
          однотипная пр регистрации просто указывается что пользователь являеться представителем юридического лица возможно предусмотреть
          загрузки доверенности);
	- любой пользователь может выступать в роли заказчика или исполнителя;
	- заказчик создает форму заказа, с описанием сроков и условий исполнения (покупка товара, доставка товара, услуга и т.д.) 
	  и отправляет запрос на заключение соглашения(договора) по email, SMS-ссылкой и т.д.;
	- исполнитель переходит по ссылке на страницу заключения договора, принимает условия или вностит дополнения отправляет свой выбор обратно
          заказчику подписанный или исправленный и подписаный документ;
        - заказчик читает подписанный договор с исправлениями или без и подписывает или вносит свои предложения подписывает и отправляет в случае
          изменений закахчику. Как только обе стороны подпишут (согласятся) с сусловиями документ переходит в стадию исполнения;
	- после согласования контракта заказчик вносит платёж на площадку который находится на площадке до выполнения сроков договора и после спустя 
          10 дней(примерно для предъявления претензий по гарантии например если заказчик подаст спор спустя нсколько дней вслучае брака или др.);
	- в случае возникновения спора с любой строны подаеётся соответствующая форма и приводятся доказательства(фото, видео, текстовое описание);
	- по завершению спора выносится решение с удовлетворением полностью или частичным спора или варианты разрешения. 

2. Минимальное количество таблиц - 10;
Архитектура базы данных по проекту "Арбитр":
	Database - Arbitr;
		Tables:
			1. users - пользователи(телефон, электронная почта, пароль, дата регистрации(удаления));
			2. profiles_persons - профили физических лица(имя, фамилия, дата рождения, фото, город, дата изменеия);
			3. profiles_company - профили юридических лиц (название, ИНН, ОГРН, имя представителя, фамилия представителя
			  фото представителя, фото(логотип компании), город, дата изменения);
			4. form_contracts - контракты (номер, заказчик, исполнитель, название договора, условия, дата начала, дата завершения, 
			   сумма, статус, дата создания, дата закрытия, дата изменения);
			5. list_contracts - контракты с указанием текущего статуса(создан, подписан, исполнен, ведётся спор)
                        6. form_disputes - споры (номер, заказчик, исполнитель, название спора, текст претензии, статус, дата создания, дата закрытия, дата изменения);
                        7. list_disputes - споры с указанием текущего статуса(создан, отклонён, принят, частично удовлетворён)
                        8. reputation - репутация (пользователь, репутация(надёжный, не надёжный, новичок, проверенный,), дата создания, дата изменения);
                        9. group_list нахождение в группе заказчиков или исполнителей(номер, пользователь, группа(заказчик, исполнитель))
                        10. messages сообщения (номер, кто отправил, кому отправил, текст, дата);
  

3. Скрипты создания структуры БД (с первичными ключами, индексами, внешними ключами);
	Основной скрипт создания структуры БД - Arbitr.sql

4. Создать ERDiagram для БД;
	Файл ERDiagram - ER Diagram.jpg

5. Скрипты наполнения БД данными;
	Скрипт наполнения БД находится в папке Data_script - fulldb-23-12-2019-08-35-beta.sql

6. Скрипты характерных выборок (включающие группировки, JOIN'ы, вложенные таблицы);

-- выводим общую сумму сделок по статусам контрактов(создан, подписан, исполнен, ведётся спор) и сумму каждого контракта
SELECT
	fc.id,
	CONCAT(pp1.first_name,' ',pp1.last_name) AS client, 
	CONCAT(pp2.first_name,' ',pp2.last_name) AS executor, 
	fc.price AS price, 
	SUM(fc.price) OVER(PARTITION BY lc.status) AS sum_of_status, 
	lc.status AS status
FROM 
	form_contracts fc JOIN list_contracts lc ON fc.id = lc.id_contracts
	JOIN profiles_persons pp1 ON pp1.person_id = fc.client_id
	JOIN profiles_persons pp2 ON pp2.person_id = fc.executor_id;
	
-- сумма сделок по месяцам текущего года и общее число за этот год
SELECT
	DISTINCT CONCAT(YEAR(fc.created_at),'-',MONTH(fc.created_at)) AS month_data,
	SUM(fc.price) OVER(PARTITION BY MONTH(fc.created_at)) AS total_month,
	SUM(fc.price) OVER(PARTITION BY YEAR(fc.created_at)) AS total_year
FROM 
	form_contracts fc WHERE created_at > CONCAT(YEAR(NOW() - INTERVAL 1 YEAR),'-12-31');
SELECT MONTH(created_at), (NOW() - INTERVAL 1 YEAR) from form_contracts;


-- сумма сделок по статусу контрактов в текущем году
SELECT 
	COUNT(*) as total_contracts, 
	SUM(price) as tottal_sum, 
	status FROM form_contracts fc JOIN list_contracts lc ON fc.id = lc.id_contracts 
WHERE created_at > CONCAT(YEAR(NOW() - INTERVAL 1 YEAR),'-12-31') 
GROUP BY status; 


-- выбираем определенного пользователя и считаем с кем он больше всего переписывался(делал по аналогии как на
-- лекциях только через табличные выражения cte) такая выборка может пригодиться для разрешения споров 
WITH dt AS (SELECT 
				from_user_id, 
				to_user_id,
				COUNT(from_user_id) as total
			FROM messages WHERE from_user_id = 39 OR to_user_id = 39 GROUP BY from_user_id, to_user_id ORDER BY total DESC) 
SELECT
	CONCAT(pp1.first_name,' ',pp1.last_name) AS `from`,
	CONCAT(pp2.first_name,' ',pp2.last_name) AS `to`,
	dt1.total+dt2.total AS total_message
FROM 
	dt dt1 JOIN dt dt2 ON dt1.to_user_id = dt2.from_user_id
	JOIN profiles_persons pp1 ON pp1.person_id = dt1.from_user_id
	JOIN profiles_persons pp2 ON pp2.person_id = dt1.to_user_id  limit 1;


-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- выборка самых двух общительных пользователей(вроде бы самый простой по смыслу запрос однако дня два я поломал голову что бы его реализовать
-- иммено в таком виде!!! он мне нужен был для посмыслу использовать в спорах например! решил пока его несделаю курсовую сдавать не буду!) 
WITH dt AS (SELECT from_user_id, to_user_id, COUNT(from_user_id) AS total 
				FROM messages 
				GROUP BY from_user_id, to_user_id ORDER BY total DESC),
	 dt2 AS (SELECT dt3.from_user_id, dt3.to_user_id, dt3.total 
	 			FROM dt dt3 JOIN dt dt4 ON (dt3.from_user_id != dt4.to_user_id) AND (dt3.to_user_id != dt4.from_user_id)),
	 dt5 AS (SELECT dt6.from_user_id, dt6.to_user_id, dt6.total 
	 			FROM dt dt6 JOIN dt2 dt7 ON (dt6.from_user_id != dt7.from_user_id) and (dt6.to_user_id != dt7.to_user_id))
SELECT
	CONCAT(pp1.first_name,' ',pp1.last_name) AS `from`,
	CONCAT(pp2.first_name,' ',pp2.last_name) AS `to`,
	dt2.total+dt5.total AS total_message
FROM 
	dt2 
	JOIN dt5 ON dt2.from_user_id = dt5.to_user_id and dt2.to_user_id = dt5.from_user_id
	JOIN profiles_persons pp1 ON pp1.person_id = dt2.from_user_id
	JOIN profiles_persons pp2 ON pp2.person_id = dt5.from_user_id;
-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


7. Представления (минимум 2);

	1. Выводит Id, имя фамилю отчество, дату рождения, почту, телефон пользователей зарегистрированных в текущем
           году(год вычесляется автоматически представление работает от системного времени)

CREATE OR REPLACE VIEW new_persons(id, name, birthday, email, phone) AS SELECT 
	u.id, 
	CONCAT(pp.first_name,' ',pp.last_name,' ',pp.pat_name), 
	pp.birthday, u.email, 
	u.phone 
FROM 
	users u  
JOIN profiles_persons pp ON pp.person_id = u.id 
WHERE u.created_at > CONCAT(YEAR(NOW() - INTERVAL 1 YEAR),'-12-31');

SELECT * FROM new_persons;

	2. Выводит имена заказчиков и исполнителей, id контрактов и дату завершения всех завершенные 
	   в текущем году контрактов(год вычисляется автоматически от системного времени)

CREATE OR REPLACE VIEW contract_executor AS SELECT 
	fc.id as contractID, 
	CONCAT(pp.first_name,' ',pp.last_name) as client, 
	CONCAT(pp2.first_name,' ',pp2.last_name) as executor,
	fc.end_work as End_work,
	lc.status as status
FROM users u JOIN form_contracts fc ON u.id = fc.client_id 
JOIN list_contracts lc ON lc.id_contracts = fc.id
JOIN profiles_persons pp ON pp.person_id = fc.client_id
JOIN profiles_persons pp2 ON pp2.person_id = fc.executor_id
WHERE fc.created_at LIKE CONCAT(YEAR(NOW()),'%') AND lc.status = 'executed';
SELECT * FROM form_contracts as pc;
SELECT * FROM profiles_persons;

SELECT * FROM contract_executor;

8. Хранимые процедуры / триггеры / функции;


-- Триггеры:
	1. Тригер на таблицу form_contracts. При создании контракта автоматически добавляет запись в list_contracts
	id контракта и статуст 'created' для последующей проверке и отправке исполнителю запроса на заключение контракта

DROP TRIGGER IF EXISTS form_contracts_insert;
DELIMITER //
CREATE TRIGGER form_contracts_insert AFTER INSERT ON form_contracts
FOR EACH ROW
BEGIN
	INSERT INTO list_contracts VALUE (NEW.id, 'created');
END//
DELIMITER ;

	2. Аналогичный тригир наvтаблицу споров. Добавляет в таблицу list_dispute запись с id спора и статусом 'registered'

DROP TRIGGER IF EXISTS form_dispute_insert;
DELIMITER //
CREATE TRIGGER form_dispute_insert AFTER INSERT ON form_disputes
FOR EACH ROW
BEGIN
	INSERT INTO list_disputes VALUE (NEW.id, 'registered');;
END//
DELIMITER ;


-- Процедура:
-- 3. Процедура удаляет все контракты со статусом "создан" более 6 месяцев назад по которым нет движения
--    соответственно подтверждения со стороны исполнителя.
DROP PROCEDURE IF EXISTS clear_contracts;
DELIMITER //
CREATE PROCEDURE clear_contracts() 
BEGIN
	DELETE FROM form_contracts 
	WHERE id in 
		(SELECT fc.id 
			FROM form_contracts fc JOIN list_contracts lc ON fc.id = lc.id_contracts 
				WHERE lc.status = 'created' 
				AND fc.created_at < CONCAT(YEAR(NOW()),'-',MONTH(NOW() - INTERVAL 6 MONTH),'-',DAY(NOW())));
END//
DELIMITER ;

CALL clear_contracts();


-- Функции:
функция last_month возвращает дату уменьшенную на число указанных месяцев от текущей даты
данная функция используется длы ваборок курсового проекта

DROP FUNCTION IF EXISTS last_month;
DELIMITER //
CREATE FUNCTION last_month(num INT)
RETURNS DATE NO SQL 
BEGIN
	RETURN CONCAT(YEAR(NOW()),'-',MONTH(NOW() - INTERVAL num MONTH),'-',DAY(NOW()));
END//
DELIMITER ;

select now(), last_month(7);

9. Сделал прототип примложения(в NinjaMock) находится в папка  "Prototyp projet" так как мне кажетя, что сейча тенденция
   идёт в сторону мобильных устройств и покупки или продажи в магазинах инстаграмм фейсбук вк и т.д. совершаются восновном
   с мобильного устройства поэтому прототип делал для мобильника, но и полноценный сайт тоже предусмотрен. Сделал
   несколько тестовых страниц примерного представления проекта   

10. Также сделал дамп базы курсовогопроекта так как дорабатывал данные после наполнения БД(письма самому себе, рандом в id и прочие 
    косметические штрихи для приближения к реальным условия) - arbitr_dump_25.12.2019.sql

Итог: в моём курсовом проекте в соответствии со структурой может показаться не совсем правильное использование запросов, функций, тригеров и процедур
в частности я не использовал таблицу профилей юридических лиц, так как принцип включения этой таблицы в работу лишь добавит объём, 
но не меняет суть. Изначально в моём понимании проект расчитан для физических лиц, которые совершают покупки и заказывают услуги в магазинах например 
в инстаграмм, фейсбук, вконтакте и т.д., то есть там где суммы сделок не очень большие, а защита покупателй/продавцов просто не предусмотрена. Вот в этой 
связи функционал проекта изначально немного урезан, но добавление юридических лиц дополняет общую идею итогового проекта!

P/S Очень важно ваше мнение и критика такого опытного специалиста как вы, так как этот проект достаточно сложен из-за отсутсвия аналогов и реалиации с нуля!  